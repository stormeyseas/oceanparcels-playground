---
title: "Re-indexing SHOC files for OceanParcels"
author: "Tormey Reimer"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: show
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)

library(ncdf4)
library(tidyverse)
library(geosphere)
```

# Introduction

This notebook converts SHOC (Sparse Hydrodynamic Ocean Code) flow field files for use with OceanParcels. The main tasks are:

1. Extract coordinate information from SHOC files and transform to conform to NEMO grid indexing
2. Create a separate coordinates file (with no data) that parcels expects
3. Extract flowfield data (2D and 3D) and environmental (tracer) data from SHOC files and ensure that it correctly maps onto the new grid indexing

## Define file paths

The `in_files` are the original flowfield files from SHOC. The `coord_file` is an output filename - parcels prefers to have a separate coordinates file which applies to all the flowfield files, rather than storing duplicate coordinates in all the flowfield files.

```{r file-paths}
# These are the SHOC files to be re-indexed for parcels
in_files <- list.files("SHOC_flowfield_files", full.names = T) %>% 
  str_subset("readme", negate = T) %>% 
  str_subset("tasse")

# Create output directories if they doesn't exist
dir.create("RI_flowfield_files", showWarnings = F)
dir.create("RI_env_var_files", showWarnings = F)
dir.create("RI_flowfield_files/2D", showWarnings = F)
dir.create("RI_flowfield_files/3D", showWarnings = F)

# This file doesn't exist yet, we're creating it
coord_file <- "RI_flowfield_files/coord_file.nc"
```

## Load and examine first flowfield file

Open the first flowfield file to extract coordinate data and define transformations needed.

```{r load-data}
# Load flowfield data into memory
ff <- nc_open(in_files[1])

# Extract grid coordinates
x_grid <- ncvar_get(ff, "x_grid")
y_grid <- ncvar_get(ff, "y_grid") 
z_grid <- ncvar_get(ff, "z_grid")
botz <- ncvar_get(ff, "botz")

# View ranges
x_dist <- distHaversine(p1 = c(range(x_grid, na.rm = TRUE)[1], range(y_grid, na.rm = TRUE)[1]), c(range(x_grid, na.rm = TRUE)[2], range(y_grid, na.rm = TRUE)[1]))
y_dist <- distHaversine(p1 = c(range(x_grid, na.rm = TRUE)[1], range(y_grid, na.rm = TRUE)[1]), c(range(x_grid, na.rm = TRUE)[1], range(y_grid, na.rm = TRUE)[2]))
cat("botz range:", range(botz, na.rm = TRUE), "\n")
cat("x_grid range:", range(x_grid, na.rm = TRUE), "--- approx", x_dist, "m \n")
cat("y_grid range:", range(y_grid, na.rm = TRUE), "--- approx", y_dist, "m \n")

# Close the file
nc_close(ff)
```

## NEMO vs SHOC Grid Indexing

NEMO is discretised on an Arakawa C-grid. (U and V velocities are not located on the same nodes). To interpolate U, V velocities on a C-grid, parcels needs to read the f-nodes, which are located on the corners of the cells.

According to NEMO's documentation, NEMO is indexed as follows in the horizontal:

```
 ____V[ij]___.f[ij]
|            |
|            |
|     .T[ij] |U[ij]
|            |
|____________|
```

Where i and j are increasing in the horizontal and vertical directions respectively and T is the location of tracer data. A NEMO cell face will therefore have nodes `[i-1,j-1]`, `[i-1,j]`, `[i,j-1]`, and `[i,j]` forming its bottom-left, top-left, bottom-right, and top-right corners respectively.

By contrast, the SHOC grid is indexed as follows in the horizontal:

```
      ____________
     |            |
     |            |
U[ij]|     .T[ij] |
     |            |
     |.___________|
 f[ij]    V[ij]
```

A SHOC cell face will therefore have nodes `[i,j]`, `[i,j+1]`, `[i+1,j]`, and `[i+1,j+1]` forming its bottom-left, top-left, bottom-right, and top-right corners respectively.

Converting these points to SHOC therefore becomes: `NEMO_F[i,j] = SHOC_F[i+1,j+1]`. At the same time, SHOC provides a bit more grid information, the depths are flipped, and a few other transformations are needed.

## Save coordinate file

```{r horizontal-grid}
# Get the grid coordinates from SHOC
i_grid <- x_grid[,1]
j_grid <- y_grid[1,]

# Can't use the bottom of each horizontal dim because we don't have T[i-1, j-1]
i_grid <- i_grid[-1]  # remove first element
j_grid <- j_grid[-1]  # remove first element  

cells_i <- length(i_grid)
cells_j <- length(j_grid)

cat("Grid dimensions after processing:\n")
cat("cells_i:", cells_i, "\n")
cat("cells_j:", cells_j, "\n")
```

```{r vertical-grid}
k_grid <- rev(z_grid) * -1  # depth needs to be flipped, and sign reversed

# Clip depth - EMS uses sediment/wind but parcels doesn't
first_ind <- which(k_grid == 0)
k_grid <- k_grid[first_ind:length(k_grid)]
cells_k <- length(k_grid)

cat("Depth grid dimensions:", cells_k, "\n")
cat("Depth range:", range(k_grid), "\n")

# Original dimensions: [i:35 j:22 k:22]
```

## Create 2D and 3D Grids

```{r create-grids}
# Create 2D latitude grid (j x i)
lat_grid <- matrix(rep(j_grid, each = cells_i), nrow = cells_j, ncol = cells_i, byrow = TRUE)
# Create 2D longitude grid (j x i)
lon_grid <- matrix(rep(i_grid, times = cells_j), nrow = cells_j, ncol = cells_i, byrow = TRUE)

# Create 3D depth grid (k x j x i)
dep_grid <- array(0, dim = c(cells_k, cells_j, cells_i))
for (k in 1:cells_k) {
  dep_grid[k, , ] <- k_grid[k]
}

cat("Grid shapes:\n")
cat("lat_grid:", dim(lat_grid), "\n")
cat("lon_grid:", dim(lon_grid), "\n")
cat("dep_grid:", dim(dep_grid), "\n")
```

## Create Coordinates NetCDF File

In the NEMO files, latitude and longitude are stored in a separate file BUT are both 3D (time dimension, with size=1). Depth is stored separately and is 1D, and the data is 4D. It's not really necessary to have a separate coordinates file but it might save some memory, and parcels is expecting it.

```{r create-coord-file}
# Define dimensions
dim_i <- ncdim_def("i", "", 1:cells_i)
dim_j <- ncdim_def("j", "", 1:cells_j)  
dim_k <- ncdim_def("k", "", 1:cells_k)

# Define variables
var_lat <- ncvar_def("lat_grid", "degrees_north", list(dim_j, dim_i), 
                     longname = "Latitude", prec = "float")
var_lon <- ncvar_def("lon_grid", "degrees_east", list(dim_j, dim_i), 
                     longname = "Longitude", prec = "float")
var_dep <- ncvar_def("dep_grid", "m", list(dim_k, dim_j, dim_i), 
                     longname = "Vertical depth", prec = "float")

# Create NetCDF file
ncout <- nc_create(coord_file, list(var_lat, var_lon, var_dep), force_v4 = TRUE)

# Write data to file
ncvar_put(ncout, var_lat, lat_grid)
ncvar_put(ncout, var_lon, lon_grid)
ncvar_put(ncout, var_dep, dep_grid)

# Add global attributes
ncatt_put(ncout, var_dep, "positive", "down")

# Close the coordinate file
nc_close(ncout)

cat("Coordinate file created:", coord_file, "\n")
```

## Re-index flowfield files

Now that we have the coordinates file and we know what transformations need to be done, we can process all the data. The following transformations need to be made:
1. In the horizontal, flowfields (both 2D and 3D) need to have the final datapoint in both the i and j directions dropped. This data will be lost but it will ensure that the data correctly maps onto the coordinate file and matches it's dimension sizes.
2. Tracer data will have the first datapoint in the i and j directions dropped, identical to what was done in the coordinates file.
2. In the vertical k dimension, all data (flowfield and tracer) needs to be transformed in the same way as for the coordinates file (flipped, clipped, and sign reversed).
3. The time dimension of all data must be expressed in total seconds, with the first record of the first file starting at 0 seconds.

```{r process-data}
mo <- 1
in_name <- in_files[mo]
out_name_2D <- file.path("RI_flowfield_files/2D", basename(in_name))
out_name_3D <- file.path("RI_flowfield_files/3D", basename(in_name))

nc <- nc_open(in_name)

# Transform time
if (mo == 1) {
  t <- transform_time(nc, start_time = NA)
  start_time <- get_first_time(nc)
} else {
  t <- transform_time(nc, start_time = start_time)
}

i_len <- nc$dim$i_left$len
j_len <- nc$dim$j_left$len
k_len <- nc$dim$k_centre$len
i_len*j_len*(k_len-3)

10289/(i_len*j_len)

# 3D velocity fields
u1_3d <- ncvar_get(nc, "u1mean") # dims [10289, 361]
u2_3d <- ncvar_get(nc, "u2mean")
w_3d <- ncvar_get(nc, "wmean")

# 2D velocity fields (depth-averaged)
u1_2d <- ncvar_get(nc, "u1vmean")
u2_2d <- ncvar_get(nc, "u2vmean")
kz_2d <- ncvar_get(nc, "Kzmean")

# Extract environmental tracer data
cat("Extracting environmental tracers...\n")
salt <- ncvar_get(nc, "salt")
temp <- ncvar_get(nc, "temp")
swr <- ncvar_get(nc, "swr")

# nc$dim$ns3 10289

22*34*22

nc_close(nc)
```

```{r time-functions}
transform_time <- function(nc, start_time = NA) {
  # Get time data
  t <- ncvar_get(nc, "t")

  # If start time is not given, extract from data
  time_units <- nc$var$t$units %>% str_remove("days since ") %>% str_remove(" [+]10")
  time_reference <- lubridate::parse_date_time2(time_units, orders = "%Y-%m-%d %H:%M:%S")
  t <- time_reference + lubridate::duration(t, "days")

  if (is.na(start_time)) {
    # If no start time is given, time starts at 0
    new_t <- t - t[1] # in seconds automatically
  } else {
    new_t <- t - start_time
  }
  
  return(as.numeric(new_t))
}

get_first_time <- function(nc) {
  t <- ncvar_get(nc, "t")[1]
  time_units <- nc$var$t$units %>% str_remove("days since ") %>% str_remove(" [+]10")
  time_reference <- lubridate::parse_date_time2(time_units, orders = "%Y-%m-%d %H:%M:%S")
  t <- time_reference + lubridate::duration(t, "days")
  return(t)
}
```

```{r horizontal-grid-functions}
transform_flow_hgrid <- function(vardata) {
  var
}
```

## Process Each Flow Field File

```{r process-files}
# Process each file
for (mo in 1:length(in_files)) {
  
  cat("\n=== Processing file", mo, "of", length(in_files), "===\n")
  cat("Input file:", in_files[mo], "\n")
  
  in_name <- in_files[mo]
  out_name <- file.path("RI_flowfield_files", basename(in_name))
  cat("Output file:", out_name, "\n")
  
  # Open input file
  df <- nc_open(in_name)
  
  # Get time information
  times <- ncvar_get(df, "t")
  tt <- length(times)
  
  # Get time units
  time_units <- ncatt_get(df, "t", "units")$value
  
  cat("Time units:", time_units, "\n")
  cat("Number of time steps:", tt, "\n")
  
  # Examine file structure for first file only
  if (mo == 1) {
    cat("Available variables in SHOC file:\n")
    var_names <- names(df$var)
    print(var_names)
    cat("\n")
    
    # Print dimensions of key variables
    for (var_name in c("u1mean", "u2mean", "wmean", "u1vmean", "u2vmean", "Kzmean", "salt", "temp", "swr")) {
      if (var_name %in% var_names) {
        var_dims <- df$var[[var_name]]$dim
        dim_names <- sapply(var_dims, function(x) x$name)
        dim_sizes <- sapply(var_dims, function(x) x$len)
        cat(var_name, "dimensions:", paste(dim_names, collapse=" x "),
            "(", paste(dim_sizes, collapse=" x "), ")\n")
      }
    }
    cat("\n")
  }
  
  # Extract velocity fields
  cat("Extracting velocity fields...\n")
  
  
  
  # Transform time variable to seconds with first file starting at 0
  cat("Processing time variable...\n")
  if (mo == 1) {
    # Store the first time value as reference
    time_offset <<- times[1]  # Global assignment
  }
  times_seconds <- (times - time_offset) * time_delta_seconds
  
  cat("Time range for this file: ", range(times_seconds), " seconds\n")
  
  # Apply grid transformations according to NEMO vs SHOC indexing
  cat("Applying grid transformations...\n")
  
  # For SHOC -> NEMO conversion, we need to:
  # - Remove the first row/column to align with coordinate grid
  # - Flip vertical dimension for 3D variables
  # - Handle the depth indexing
  
  # Get original dimensions
  orig_dims <- dim(u1_3d)
  cat("Original 3D dimensions:", paste(orig_dims, collapse=" x "), "\n")
  
  # Transform 3D fields (remove first i,j indices and flip k dimension)
  if (length(orig_dims) == 4) { # k, j, i, t format
    # Remove first i and j indices, keep k and t
    u1_3d_trans <- u1_3d[first_ind:dim(u1_3d)[1], 2:dim(u1_3d)[2], 2:dim(u1_3d)[3], ]
    u2_3d_trans <- u2_3d[first_ind:dim(u2_3d)[1], 2:dim(u2_3d)[2], 2:dim(u2_3d)[3], ]
    w_3d_trans <- w_3d[first_ind:dim(w_3d)[1], 2:dim(w_3d)[2], 2:dim(w_3d)[3], ]
    salt_trans <- salt[first_ind:dim(salt)[1], 2:dim(salt)[2], 2:dim(salt)[3], ]
    temp_trans <- temp[first_ind:dim(temp)[1], 2:dim(temp)[2], 2:dim(temp)[3], ]
    swr_trans <- swr[first_ind:dim(swr)[1], 2:dim(swr)[2], 2:dim(swr)[3], ]
    
    # Flip the depth dimension (first dimension)
    u1_3d_trans <- u1_3d_trans[dim(u1_3d_trans)[1]:1, , , ]
    u2_3d_trans <- u2_3d_trans[dim(u2_3d_trans)[1]:1, , , ]
    w_3d_trans <- w_3d_trans[dim(w_3d_trans)[1]:1, , , ]
    salt_trans <- salt_trans[dim(salt_trans)[1]:1, , , ]
    temp_trans <- temp_trans[dim(temp_trans)[1]:1, , , ]
    swr_trans <- swr_trans[dim(swr_trans)[1]:1, , , ]
  }
  
  # Transform 2D fields (remove first i,j indices)
  if (length(dim(u1_2d)) == 3) { # j, i, t format
    u1_2d_trans <- u1_2d[2:dim(u1_2d)[1], 2:dim(u1_2d)[2], ]
    u2_2d_trans <- u2_2d[2:dim(u2_2d)[1], 2:dim(u2_2d)[2], ]
    kz_2d_trans <- kz_2d[2:dim(kz_2d)[1], 2:dim(kz_2d)[2], ]
  }
  
  cat("Transformed 3D dimensions:", paste(dim(u1_3d_trans), collapse=" x "), "\n")
  cat("Transformed 2D dimensions:", paste(dim(u1_2d_trans), collapse=" x "), "\n")
  
  # Create output file names
  out_3d_name <- file.path("RI_flowfield_files/3D", basename(in_name))
  out_2d_name <- file.path("RI_flowfield_files/2D", basename(in_name))
  out_env_name <- file.path("RI_env_var_files", basename(in_name))
  
  cat("Writing 3D velocity fields to:", out_3d_name, "\n")
  
  # Write 3D velocity fields
  # Define dimensions for 3D output
  dim_time <- ncdim_def("time", "seconds", times_seconds, unlim = TRUE)
  dim_i_3d <- ncdim_def("i", "", 1:dim(u1_3d_trans)[3])
  dim_j_3d <- ncdim_def("j", "", 1:dim(u1_3d_trans)[2])
  dim_k_3d <- ncdim_def("k", "", 1:dim(u1_3d_trans)[1])
  
  # Define 3D velocity variables
  var_u1_3d <- ncvar_def("u1", "m/s", list(dim_k_3d, dim_j_3d, dim_i_3d, dim_time),
                         longname = "Eastward velocity", prec = "float")
  var_u2_3d <- ncvar_def("u2", "m/s", list(dim_k_3d, dim_j_3d, dim_i_3d, dim_time),
                         longname = "Northward velocity", prec = "float")
  var_w_3d <- ncvar_def("w", "m/s", list(dim_k_3d, dim_j_3d, dim_i_3d, dim_time),
                        longname = "Vertical velocity", prec = "float")
  
  # Create 3D NetCDF file
  ncout_3d <- nc_create(out_3d_name, list(var_u1_3d, var_u2_3d, var_w_3d), force_v4 = TRUE)
  
  # Write 3D data
  ncvar_put(ncout_3d, var_u1_3d, u1_3d_trans)
  ncvar_put(ncout_3d, var_u2_3d, u2_3d_trans)
  ncvar_put(ncout_3d, var_w_3d, w_3d_trans)
  
  # Add time attributes
  ncatt_put(ncout_3d, "time", "units", "seconds since start of simulation")
  
  nc_close(ncout_3d)
  
  cat("Writing 2D velocity fields to:", out_2d_name, "\n")
  
  # Write 2D velocity fields
  # Define dimensions for 2D output
  dim_i_2d <- ncdim_def("i", "", 1:dim(u1_2d_trans)[2])
  dim_j_2d <- ncdim_def("j", "", 1:dim(u1_2d_trans)[1])
  
  # Define 2D velocity variables
  var_u1_2d <- ncvar_def("u1", "m/s", list(dim_j_2d, dim_i_2d, dim_time),
                         longname = "Depth-averaged eastward velocity", prec = "float")
  var_u2_2d <- ncvar_def("u2", "m/s", list(dim_j_2d, dim_i_2d, dim_time),
                         longname = "Depth-averaged northward velocity", prec = "float")
  var_kz_2d <- ncvar_def("Kz", "m^2/s", list(dim_j_2d, dim_i_2d, dim_time),
                         longname = "Vertical diffusivity", prec = "float")
  
  # Create 2D NetCDF file
  ncout_2d <- nc_create(out_2d_name, list(var_u1_2d, var_u2_2d, var_kz_2d), force_v4 = TRUE)
  
  # Write 2D data
  ncvar_put(ncout_2d, var_u1_2d, u1_2d_trans)
  ncvar_put(ncout_2d, var_u2_2d, u2_2d_trans)
  ncvar_put(ncout_2d, var_kz_2d, kz_2d_trans)
  
  # Add time attributes
  ncatt_put(ncout_2d, "time", "units", "seconds since start of simulation")
  
  nc_close(ncout_2d)
  
  cat("Writing environmental variables to:", out_env_name, "\n")
  
  # Write environmental variables
  # Define environmental variables
  var_salt <- ncvar_def("salt", "psu", list(dim_k_3d, dim_j_3d, dim_i_3d, dim_time),
                        longname = "Salinity", prec = "float")
  var_temp <- ncvar_def("temp", "degC", list(dim_k_3d, dim_j_3d, dim_i_3d, dim_time),
                        longname = "Temperature", prec = "float")
  var_swr <- ncvar_def("swr", "W/m^2", list(dim_k_3d, dim_j_3d, dim_i_3d, dim_time),
                       longname = "Shortwave radiation", prec = "float")
  
  # Create environmental NetCDF file
  ncout_env <- nc_create(out_env_name, list(var_salt, var_temp, var_swr), force_v4 = TRUE)
  
  # Write environmental data
  ncvar_put(ncout_env, var_salt, salt_trans)
  ncvar_put(ncout_env, var_temp, temp_trans)
  ncvar_put(ncout_env, var_swr, swr_trans)
  
  # Add time attributes
  ncatt_put(ncout_env, "time", "units", "seconds since start of simulation")
  
  nc_close(ncout_env)
  
  cat("File", mo, "processing complete!\n")
  
  # Close input file
  nc_close(df)
}

cat("\nProcessing complete!\n")
```

